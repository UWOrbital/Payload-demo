#include "compression.h"
#include "math.h"
#include "stdlib.h"
#include "stdio.h"
#include "huff.h"

#define BLOCK_SIZE 8

#define FILE_PATH ".\\test.bin"

#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  (byte & 0x80 ? '1' : '0'), \
  (byte & 0x40 ? '1' : '0'), \
  (byte & 0x20 ? '1' : '0'), \
  (byte & 0x10 ? '1' : '0'), \
  (byte & 0x08 ? '1' : '0'), \
  (byte & 0x04 ? '1' : '0'), \
  (byte & 0x02 ? '1' : '0'), \
  (byte & 0x01 ? '1' : '0')

FILE *fptr;
static uint16_t buf;
static uint8_t nbit;

const float quantization_table[8][8] = {
        {16, 11, 10, 16, 24, 40, 51, 61},
        {12, 12, 14, 19, 26, 58, 60, 55},
        {14, 13, 16, 24, 40, 57, 69, 56},
        {14, 17, 22, 29, 51, 87, 80, 62},
        {18, 22, 37, 56, 68, 109, 103, 77},
        {24, 35, 55, 64, 81, 104, 113, 92},
        {49, 64, 78, 87, 103, 121, 120, 101},
        {72, 92, 95, 98, 112, 100, 103, 99}
};

const float col_quantization_table[8][8] = {
        {17, 18, 24, 47, 99, 99, 99, 99},
        {18, 21, 26, 66, 99, 99, 99, 99},
        {24, 26, 56, 99, 99, 99, 99, 99},
        {47, 66, 99, 99, 99, 99, 99, 99},
        {99, 99, 99, 99, 99, 99, 99, 99},
        {99, 99, 99, 99, 99, 99, 99, 99},
        {99, 99, 99, 99, 99, 99, 99, 99},
        {99, 99, 99, 99, 99, 99, 99, 99}
};

void prv_array_to_matrix(float **matrix, const float *arr, int matrix_num);
void prv_compress_block(float **Matrix, uint8_t channel, enum Type_t type);

/* Function is used to take an entire image and encode it into a .bin file
 * Currently, this uses dynamically allocated memory and should be changed to be entirely static once we know
 * what size our images will typically be */
void compress_image(Image *img){
    /* Generate YCbCr data from RGB input*/
    generate_ycbcr_data(img);

    /* Separate channels into Y Cb Cr in a 3 * (w*h) matrix */
    float **channels = calloc_mat(3, img->width*img->height);
    int index = 0;
    for(unsigned char *p = img->data, *pg = img->YCbCr_data; p != img->data + img->size; p += img->channels, pg += img->channels, index++) {
        channels[0][index] = *pg;     // Y
        channels[1][index] = *(pg+1); // Cb
        channels[2][index] = *(pg+2); // Cr
    }

    /* Subsample Cb and Cr - LEAVE UNTIL LATER */
    /* This can probably be done by changing functionality from Y... Cb... Cr to Y, Cb, Cr, and skipping over
     * a few colour values at a time, and take care of the reconstruction in the decoder
    */

    /* Generate huffman codes given a table and its type
     * Currently, this function is passed standard tables that are defined in huff.c
     * As in improvement to this, custom huffman tables should be generated by first parsing through the whole image
     * and generating the tables */
    generate_huff_codes(&huffman_tables[LUM_DC_TABLE], LUM_DC_TABLE);
    generate_huff_codes(&huffman_tables[LUM_AC_TABLE], LUM_AC_TABLE);
    generate_huff_codes(&huffman_tables[COL_DC_TABLE], COL_DC_TABLE);
    generate_huff_codes(&huffman_tables[COL_AC_TABLE], COL_AC_TABLE);

    /* TESTING */
//    printf("m: "BYTE_TO_BINARY_PATTERN" "BYTE_TO_BINARY_PATTERN"\n",
//           BYTE_TO_BINARY(huffman_tables[LUM_AC_TABLE].codes[huffman_tables[LUM_AC_TABLE].EOB_code_index]>>8),
//           BYTE_TO_BINARY(huffman_tables[LUM_AC_TABLE].codes[huffman_tables[LUM_AC_TABLE].EOB_code_index]));
//
//    printf("m: "BYTE_TO_BINARY_PATTERN" "BYTE_TO_BINARY_PATTERN"\n",
//           BYTE_TO_BINARY(huffman_tables[COL_AC_TABLE].codes[0]>>8),
//           BYTE_TO_BINARY(huffman_tables[COL_AC_TABLE].codes[0]));
//
//    printf("EOB COL AC Code len: %d\n", huffman_tables[COL_AC_TABLE].EOB_code_len);
//    exit(1);
    /* TESTING */

    /* buf and nbit are statically declared and are used to write to the .bin file
     * fptr is the file pointer to write to */
    buf = 0;
    nbit = 0;
    fptr = fopen(FILE_PATH,"wb");

    /* Repeat the compression for each channel
     * This is not the JPEG standard way of encoding, typically the bitstream is read as Y Cb Cr (or slightly
     * differently if subsampled), this program instead codes each channel on its own, sending Y Y ... Y Cb .... Cb and
     * on. This could be changed later depending on the decoding process or the image loader we choose to use or make */
    // for 8x8 matrix in image
    int num_matricies = (img->height * img->width) / (BLOCK_SIZE * BLOCK_SIZE);
    float **YMatrix = calloc_mat(BLOCK_SIZE, BLOCK_SIZE);
    float **CbMatrix = calloc_mat(BLOCK_SIZE, BLOCK_SIZE);
    float **CrMatrix = calloc_mat(BLOCK_SIZE, BLOCK_SIZE);
    enum Type_t types[3] = {LUM, COL, COL};
    for (int m = 0; m < num_matricies; m++) {
        prv_array_to_matrix(YMatrix, &channels[0][m * 64], m);
        prv_array_to_matrix(CbMatrix, &channels[1][m * 64], m);
        prv_array_to_matrix(CrMatrix, &channels[2][m * 64], m);
        prv_compress_block(YMatrix, 0, types[0]);
        prv_compress_block(CbMatrix, 1, types[1]);
        prv_compress_block(CrMatrix, 2, types[2]);
//        if(m==5)exit(1);
    }
    free_mat(YMatrix);
    free_mat(CbMatrix);
    free_mat(CrMatrix);
    free_mat(channels);
}

void prv_compress_block(float **Matrix, uint8_t channel, enum Type_t type){
    block_dct(Matrix, BLOCK_SIZE, BLOCK_SIZE);
    quantize(Matrix, type);
    huffman_encode(Matrix, channel, type);
}

void block_dct(float **Matrix, int N, int M){
    float **tmpMatrix = calloc_mat(8, 8);
    float sum = 0, Cu, Cv;

    int i, j, u, v;
    for (u = 0; u < N; ++u) {
        for (v = 0; v < M; ++v) {
            sum = 0;
            for (i = 0; i < N; i++) {
                for (j = 0; j < M; j++) {
                    sum += Matrix[i][j] * cos(M_PI/((float)N)*(i+1./2.)*u)*cos(M_PI/((float)M)*(j+1./2.)*v);
                }
            }
            if (u==0) Cu=1/sqrt(2); else Cu=1;
            if (v==0) Cv=1/sqrt(2); else Cv=1;
            tmpMatrix[u][v] = 1/4.0*Cu*Cv*sum;
        }
    }

    for (int a = 0; a < 8; ++a) {
        for (int b = 0; b < 8; ++b) {
            Matrix[a][b] = tmpMatrix[a][b];
        }
    }

    free_mat(tmpMatrix);
}

void quantize(float **Matrix, enum Type_t type){
    const float (*table)[8][8];
    if(type == LUM)
        table = &quantization_table;
    else
        table = &col_quantization_table;

    for (int i = 0; i < 8; ++i) {
        for (int j = 0; j < 8; ++j) {
            Matrix[i][j] = (int)(Matrix[i][j]/(*table)[i][j]);
        }
    }
}

void huffman_encode(float **Matrix, uint8_t channel, enum Type_t type){
    static int prev_DC_Coeff[3] = { 0 };

    enum Table_t DC_Type;
    enum Table_t AC_Type;
    if(type == LUM) {
        DC_Type = LUM_DC_TABLE;
        AC_Type = LUM_AC_TABLE;
    } else {
        DC_Type = COL_DC_TABLE;
        AC_Type = COL_AC_TABLE;
    }

    int *output = calloc(64, sizeof(int));
    zig_zag_order(output, Matrix);

    /* DC Coefficient */
    /* Edit the symbol to be relative to the previous symbol */
    uint16_t tmp = output[0];
    output[0] = output[0] - prev_DC_Coeff[channel];
    /* Fetch the length of the huffman symbol */
    uint8_t fetch_bit = (uint8_t)(floor(log2(abs(output[0]))) + 1);
    uint8_t sum_index = 0;
    uint8_t fetch_index = 0;
    // fetch_bit acts as the index of the symbol because dc symbols == index
    if(output[0] != 0) {
        while(sum_index < fetch_bit){
            sum_index += huffman_tables[DC_Type].offsets[fetch_index];
            fetch_index++;
        }
    } else {
        fetch_index = 2;
    }
    // Write the DC huffman symbol, that is, the code for the length of the DC Coefficient
    write_buffer(&buf, &nbit, fptr, huffman_tables[DC_Type].codes[fetch_bit], fetch_index);
    // Write the DC Coefficient itself
    if(output[0] < 0) output[0] = ~output[0];
    write_buffer(&buf, &nbit, fptr, (uint16_t)output[0], fetch_bit);
    prev_DC_Coeff[channel] = tmp;

    /* AC Coefficient */
    uint8_t zero_run = 0;
    for(int i = 1; i < 64; ++i){
        /*
         * For AC Coefficients, we need to keep track of the ZR (zero run), and encode the appropriate symbol
         * based on the ZR and the symbol that proceeds it.
         * This includes two special cases:
         * - 0xf0 is a run of 16 zeroes, or, a run of 15 zeroes proceeded by a zero
         * - 0x00 is the EOB, end of bytes for this block, or a run of zeroes until the end
        */
        if(output[i] == 0){
            zero_run++;
            continue;
        } else {
            while(zero_run >= 16) {
                write_buffer(&buf, &nbit, fptr, huffman_tables[AC_Type].codes[huffman_tables[AC_Type].ZRL_code_index], huffman_tables[AC_Type].ZRL_code_len);
                zero_run -= 16;
            }
            fetch_bit = (zero_run << 4);
            fetch_bit = fetch_bit | (uint8_t)(floor(log2(output[i])) + 1);
            /* Fetch an AC bit representation given the int or hex code */ // This is really slow should be fixed
            uint8_t index = 0;
            for(int j = 0; j < 162; ++j) {
                if(huffman_tables[AC_Type].symbols[j] == fetch_bit){
                    index = j;
                    break;
                }
            }
            /* Fetch the length of the huffman symbol */
            sum_index = 0;
            fetch_index = 0;
            // fetch_bit replaced with the index of the bit (see DC fetching) (add one to index to counter zero indexing)
            while(sum_index < index+1){
                sum_index += huffman_tables[AC_Type].offsets[fetch_index];
                fetch_index++;
            }
            fetch_index--;
            // Write Huffman Symbol (zr and coeff len)
            write_buffer(&buf, &nbit, fptr, huffman_tables[AC_Type].codes[index], fetch_index);
            // Write the AC Coeff itself
            if(output[i] < 0) output[i] = ~output[i];
            // last four bits of the fetch_bit represents the length in bits of the ac coefficient
            write_buffer(&buf, &nbit, fptr, (uint16_t)output[i], fetch_bit & 0b00001111);
        }
    }
    /* Write EOB to buffer*/
    write_buffer(&buf, &nbit, fptr, huffman_tables[AC_Type].codes[huffman_tables[AC_Type].EOB_code_index], huffman_tables[AC_Type].EOB_code_len);

    free(output);
}

float **calloc_mat(int dimX, int dimY){
    float **m = calloc(dimX, sizeof(float*));
    float *p = calloc(dimX*dimY, sizeof(float));
    int i;
    for(i=0; i <dimX;i++){
        m[i] = &p[i*dimY];
    }
    return m;
}

void free_mat(float **m){
    free(m[0]);
    free(m);
}

void prv_array_to_matrix(float **matrix, const float *arr, int matrix_num)
{
    int i,j,k=0;
//    k += matrix_num*64;
    for(i=0;i<8;i++)
    {
        for(j=0;j<8;j++)
        {
            matrix[i][j] = arr[k++];
        }
    }
}

